---
title: ReentrantReadWriteLock实现分析
date: 2016-11-09 10:33:13
tags: Java
categories: Java并发编程
toc: true
---

ReentrantReadWriteLock，顾名思义，支持重入，支持读锁和写锁。

## API规范相关说明

跟ReentrantLock一样，支持非公平（默认）和公平模式。
**非公平模式**下，读锁和写锁的顺序是没有指定的。不断的竞争可能导致其他读或写线程阻塞，但是性能要优于公平锁，减少线程间切换的损耗。
**公平模式**下，竞争是arrival-order策略，最先阻塞的线程最具竞争。当前锁释放后，最长等待的写锁线程将赋予写锁。没有写锁时，最长等待的读锁获取读锁。
读锁来了，如果现在有写锁或者写锁的阻塞队列不为空，获取读锁的线程将继续阻塞，直到写锁的线程不存在了且写锁阻塞队列为空。也就是说写锁比读锁高一级，有写锁存在，读锁就阻塞，没有写锁了，读锁自己竞争。
写锁来了，如果读锁且写锁都释放了，则抢占。意味着，写锁和读锁都木有阻塞的线程。
**重入**，写锁线程可以在释放锁的情况下，获取读锁，反之不允许。这也是**锁降级**的特性。
**通用实现**，CachedData，加入volatile的flag，再加double check实现写方法。
**最大的锁数**，65535写锁和读锁。

## 类图
![](http://photos.zhangzemiao.com/blog_writereadlock1.jpg)